use ast::*;

pub ast -> Vec<Statement>
    = whitespace* s:statement* whitespace* { s }

pub  single_line -> Line
    = s:statement* whitespace* comment? { Line::Statements(s) }
    / e:expression whitespace* comment? { Line::Expression(e) }

statement -> Statement
    = "let" whitespace+ ident:identifier whitespace* "=" whitespace* e:expression whitespace* ";" whitespace* {
        Statement::AssignVar(ident, e)
    }
    / "if" whitespace+ cond:expression whitespace* "{" whitespace* s:statement* whitespace* "}" whitespace* {
        Statement::If(cond, s)
    }
    / "print" whitespace* e:expression whitespace* ";" whitespace* {
        Statement::Print(e)
    }

expression -> Expr
= "!" whitespace* e:atom { Expr::UnOp(UnaryOp::Not, Box::new(e)) }
/ #infix<atom> {
    #L x (whitespace* "||" whitespace*) y { Expr::BoolChain(BoolLogic::Or, Box::new(x), Box::new(y)) }
    #L x (whitespace* "&&" whitespace*) y { Expr::BoolChain(BoolLogic::And, Box::new(x), Box::new(y)) }

    #L x (whitespace* "==" whitespace*) y { Expr::Comparison(CompOp::Equal, Box::new(x), Box::new(y)) }
       x (whitespace* "!=" whitespace*) y { Expr::Comparison(CompOp::NotEq, Box::new(x), Box::new(y)) }

    #L x (whitespace* "<" whitespace*) y { Expr::Comparison(CompOp::Lt, Box::new(x), Box::new(y)) }
       x (whitespace* "<=" whitespace*) y { Expr::Comparison(CompOp::Le, Box::new(x), Box::new(y)) }
       x (whitespace* ">" whitespace*) y { Expr::Comparison(CompOp::Gt, Box::new(x), Box::new(y)) }
       x (whitespace* ">=" whitespace*) y { Expr::Comparison(CompOp::Ge, Box::new(x), Box::new(y)) }

    #L x (whitespace* "+"  whitespace*) y { Expr::BinOp(Op::Add, Box::new(x), Box::new(y)) }
       x (whitespace* "-"  whitespace*) y { Expr::BinOp(Op::Sub, Box::new(x), Box::new(y)) }

    #L x (whitespace* "*"  whitespace*) y { Expr::BinOp(Op::Mul, Box::new(x), Box::new(y)) }
       x (whitespace* "/"  whitespace*) y { Expr::BinOp(Op::Div, Box::new(x), Box::new(y)) }
       x (whitespace* "%"  whitespace*) y { Expr::BinOp(Op::Mod, Box::new(x), Box::new(y)) }

    #R x (whitespace* "**" whitespace*) y { Expr::BinOp(Op::Exp, Box::new(x), Box::new(y)) }
}

atom -> Expr
    = "(" e:expression ")" { e }
    / v:value { Expr::Literal(v) }
    / r:reference { Expr::Reference(r) }

pub value -> Value
    = v:(number/string/boolean/array) { v }

reference -> String // Variable lookup
    = ident:identifier { ident }

array -> Value
    = "[" v:(value ** ("," whitespace*)) "]" { Value::Array(v) }

string -> Value
    // To-Do: Make escapes work
    = "\"" text:$([^"]*) "\"" { Value::String(text.to_string()) }

boolean -> Value
    = "true" { Value::Boolean(true) }
    / "false" { Value::Boolean(false) }

identifier -> String = !keyword text:$(character+ (character/digit/"_")*) { text.to_string() }

keyword = "true" / "false" / "let" / "print"

comment = #quiet<"//" .*>

number -> Value
    = s:$("-")? n:$(float) {
        Value::Num([s, n].concat().replace("_", "").parse().unwrap())
    }
    / s:$("-")? n:$(int) {
        Value::Num([s, n].concat().replace("_", "").parse().unwrap())
    }

float
    = int* "." int+

int
    = digit (digit / "_")*

digit
    = [0-9]

character
    = [a-zA-Z]

EOF = #quiet<!.>

whitespace = #quiet<[ \n\t]>
