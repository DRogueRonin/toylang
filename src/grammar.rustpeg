use ast::*;

pub ast -> Vec<Statement>
    = { unimplemented!() }

pub statement -> Statement
    = { unimplemented!() }

pub expression -> Expr
    = r:reference { Expr::Reference(r) }
    / a:arithmetic { a }
    / v:value { Expr::Literal(v) }

arithmetic -> Expr = #infix<expression> {
    #L x "+" y { Expr::Op(Op::Add, Box::new(x), Box::new(y)) }
       x "-" y { Expr::Op(Op::Sub, Box::new(x), Box::new(y)) }
    #L x "*" y { Expr::Op(Op::Mul, Box::new(x), Box::new(y)) }
       x "/" y { Expr::Op(Op::Div, Box::new(x), Box::new(y)) }
    #R x "^" y { Expr::Op(Op::Exp, Box::new(x), Box::new(y)) }
}

value -> Value
    = v:(number/string/boolean/array) { v }

reference -> String // Variable lookup
    = text:$(character+ (character / digit)*) { text.to_string() }

array -> Value
    = "[" v:(value ** ("," whitespace*)) "]" { Value::Array(v) }

string -> Value
    // To-Do: Make escapes work
    = "\"" text:$([^"]*) "\"" { Value::String(text.to_string()) }

boolean -> Value
    = "true" { Value::Boolean(true) }
    / "false" { Value::Boolean(false) }

number -> Value
    = s:$("-")? n:$(float) {
        Value::Float([s, n].concat().replace("_", "").parse().unwrap())
    }
    / s:$("-")? n:$(int) {
        Value::Int([s, n].concat().replace("_", "").parse().unwrap())
    }

// op -> Op
//     = "**" { Op::Exp }
//     / "*"  { Op::Mul }
//     / "/"  { Op::Div }
//     / "+"  { Op::Add }
//     / "-"  { Op::Sub }

float
    = int* "." int+

int
    = digit (digit / "_")*

digit
    = [0-9]

character
    = [a-zA-Z]

whitespace = #quiet<[ \n\t]>
