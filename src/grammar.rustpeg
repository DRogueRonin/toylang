use ast::*;

pub ast -> Vec<Statement>
    = whitespace* s:statement* whitespace* { s }

pub single_line -> Line
    = s:statement whitespace* comment? { Line::Statement(s) }
    / e:expression whitespace* comment? { Line::Expression(e) }

statement -> Statement
    = "let" whitespace+ ident:identifier whitespace* "=" whitespace* e:expression whitespace* ";" whitespace* {
        Statement::DeclareVar(ident, e)
    }
    / e:expression whitespace* ";" whitespace* {
        Statement::Expression(e)
    }
    / ident:identifier whitespace* op:assign_op whitespace* e:expression whitespace* ";" whitespace* {
        Statement::MutateVar(op, ident, e)
    }
    / if_s:if_statement elif_s:elif_statement* else_s:else_statement? {
        let else_if = if elif_s.len() == 0 {
            None
        } else {
            Some(elif_s)
        };
        Statement::If(if_s, else_if, else_s)
    }
    / "while" whitespace+ cond:expression whitespace* "{" whitespace* s:statement* whitespace* "}" whitespace* {
        Statement::While(cond, s)
    }
    / "print" whitespace* e:expression whitespace* ";" whitespace* {
        Statement::Print(e)
    }

if_statement -> IfStatement
    = "if" whitespace+ cond:expression whitespace* "{" whitespace* s:statement* whitespace* "}" whitespace* {
        IfStatement {
            e: cond,
            s: s,
        }
    }

elif_statement -> IfStatement
    = "elif" whitespace+ cond:expression whitespace* "{" whitespace* s:statement* whitespace* "}" whitespace* {
        IfStatement {
            e: cond,
            s: s,
        }
    }

else_statement -> Vec<Statement>
    = "else" whitespace* "{" whitespace* s:statement* whitespace* "}" whitespace* {
        s
    }

expression -> Expr
= "!" whitespace* e:atom { Expr::UnOp(UnaryOp::Not, Box::new(e)) }
/ #infix<atom> {
    #L x (whitespace* "||" whitespace*) y { Expr::BoolChain(BoolLogic::Or, Box::new(x), Box::new(y)) }
    #L x (whitespace* "&&" whitespace*) y { Expr::BoolChain(BoolLogic::And, Box::new(x), Box::new(y)) }

    #L x (whitespace* "==" whitespace*) y { Expr::Comparison(CompOp::Equal, Box::new(x), Box::new(y)) }
       x (whitespace* "!=" whitespace*) y { Expr::Comparison(CompOp::NotEq, Box::new(x), Box::new(y)) }

    #L x (whitespace* "<" whitespace*) y { Expr::Comparison(CompOp::Lt, Box::new(x), Box::new(y)) }
       x (whitespace* "<=" whitespace*) y { Expr::Comparison(CompOp::Le, Box::new(x), Box::new(y)) }
       x (whitespace* ">" whitespace*) y { Expr::Comparison(CompOp::Gt, Box::new(x), Box::new(y)) }
       x (whitespace* ">=" whitespace*) y { Expr::Comparison(CompOp::Ge, Box::new(x), Box::new(y)) }

    #L x (whitespace* "+"  whitespace*) y { Expr::BinOp(Op::Add, Box::new(x), Box::new(y)) }
       x (whitespace* "-"  whitespace*) y { Expr::BinOp(Op::Sub, Box::new(x), Box::new(y)) }

    #L x (whitespace* "*"  whitespace*) y { Expr::BinOp(Op::Mul, Box::new(x), Box::new(y)) }
       x (whitespace* "/"  whitespace*) y { Expr::BinOp(Op::Div, Box::new(x), Box::new(y)) }
       x (whitespace* "%"  whitespace*) y { Expr::BinOp(Op::Mod, Box::new(x), Box::new(y)) }

    #R x (whitespace* "**" whitespace*) y { Expr::BinOp(Op::Exp, Box::new(x), Box::new(y)) }
}

assign_op -> AssignOp
    = "="  { AssignOp::Equals }
    / "+=" { AssignOp::AddEq }
    / "-=" { AssignOp::SubEq }
    / "*=" { AssignOp::MulEq }
    / "/=" { AssignOp::DivEq }
    / "%=" { AssignOp::ModEq }

atom -> Expr
    = "(" e:expression ")" { e }
    / v:value { Expr::Literal(v) }
    / r:reference { Expr::Reference(r) }

pub value -> Value
    = v:(number/string/boolean/array) { v }

reference -> String // Variable lookup
    = ident:identifier { ident }

array -> Value
    = "[" v:(value ** ("," whitespace*)) "]" { Value::Array(v) }

string -> Value
    // To-Do: Make escapes work
    = "\"" text:$([^"]*) "\"" { Value::String(text.to_string()) }

boolean -> Value
    = "true" { Value::Boolean(true) }
    / "false" { Value::Boolean(false) }

identifier -> String = !keyword text:$(character+ (character/digit/"_")*) { text.to_string() }

keyword = "true" / "false" / "let" / "print" / "while" / "if" / "elif" / "else"

comment = #quiet<"//" [^\n\r]*>

number -> Value
    = s:$("-")? n:$(float) {
        Value::Num([s, n].concat().replace("_", "").parse().unwrap())
    }
    / s:$("-")? n:$(int) {
        Value::Num([s, n].concat().replace("_", "").parse().unwrap())
    }

float
    = int* "." int+

int
    = digit (digit / "_")*

digit
    = [0-9]

character
    = [a-zA-Z]

EOF = #quiet<!.>

whitespace = #quiet<[ \n\r\t] / comment>
